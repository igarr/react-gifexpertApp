{"version":3,"sources":["components/AddCategoryFromText.js","helpers/getGifs.js","components/GridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategoryFromText","ponCategoriaEnPadre","useState","textoParaCaja","settextoParaCaja","onSubmit","e","preventDefault","trim","length","categs","type","value","onChange","target","getGifs","categoria","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GridItem","console","log","className","src","alt","GifGrid","categorGrid","categorGridForHook","loading","state","setState","useEffect","then","gifsEncontrados","setTimeout","useFetchGifs","imagenesEncontradas","currentImg","GifExpertApp","categories","setCatergory","category","ind","propTypes","ponCategoria","PropTypes","func","isRequired","ReactDOM","render","document","getElementById"],"mappings":"oMAIaA,EAAsB,SAAC,GAA6B,IAA3BC,EAA0B,EAA1BA,oBAA0B,EAIlBC,mBAAS,0BAJS,mBAIrDC,EAJqD,KAItCC,EAJsC,KA+B5D,OACI,sBAAMC,SApBW,SAACC,GAClBA,EAAEC,iBAOEJ,EAAcK,OAAOC,OAAS,IAClCR,GAAoB,SAAAS,GAAM,OAAKP,GAAL,mBAAuBO,OAGjDN,EAAiB,MAQjB,SACI,uBACIO,KAAK,OACLC,MAAOT,EACPU,SA9Bc,SAACP,GACvBF,EAAkBE,EAAEQ,OAAOF,a,+CCRpBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAEfC,EAFe,0FAE0EC,UAAUH,GAFpF,sBAGEI,MAAOF,GAHT,cAGXG,EAHW,gBAMMA,EAAKC,OANX,uBAMTC,EANS,EAMTA,KAKFC,EAAOD,EAAKE,KAAK,SAAAC,GAAQ,IAAD,EAC1B,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAfzB,kBAkBTM,GAlBS,4CAAH,sDCATO,EAAW,SAAC,GAAsB,IAApBJ,EAAmB,EAAnBA,GAAGC,EAAgB,EAAhBA,MAAOV,EAAS,EAATA,IAIjC,OAFAc,QAAQC,IAAI,CAACN,KAAGC,QAAMV,QAGlB,sBAAKgB,UAAU,yCAAf,UACI,6BAAKN,IACL,qBAAKO,IAAKjB,EAAKkB,IAAKR,QCPnBS,EAAU,SAAC,GAAqB,IAAnBC,EAAkB,EAAlBA,YAAkB,ECChB,SAACC,GAAwB,IAAD,EAEtBrC,mBAAW,CACjCqB,KAAM,GACNiB,SAAS,IAJmC,mBAEzCC,EAFyC,KAElCC,EAFkC,KA4ChD,OAtCAV,QAAQC,IAAI,gBAAaM,GAKzBI,qBAAW,WACP5B,EAAQwB,GACPK,MAAM,SAAAC,GAGHC,YAAY,WAEZd,QAAQC,IAAIY,GACZH,EAAS,CACLnB,KAAMsB,EACNL,SAAS,MAGd,UAEJ,CAACD,IAiBJP,QAAQC,IAAI,kBACLQ,ED1CoCM,CAAaT,GAA7CU,EAH6B,EAGlCzB,KAA0BiB,EAHQ,EAGRA,QAgBhC,OACI,qCACA,mCAAOF,EAAP,OACEE,GAAW,cACb,qBAAKN,UAAU,YAAf,SAGQc,EAAoBvB,KAAK,SAAAwB,GAAU,OAClC,cAAC,EAAD,eAGOA,GAFGA,EAAWtB,aExBzBuB,EAAe,WAAO,IAAD,EAEKhD,mBAAU,CAAC,YAFhB,mBAEvBiD,EAFuB,KAEXC,EAFW,KAI9B,OACI,qCACI,8CAIA,cAAC,EAAD,CAAqBnD,oBAAuBmD,IAG5C,uBACA,6BAGQD,EAAW1B,KAAK,SAAC4B,EAAUC,GACvB,OAAO,cAAC,EAAD,CAEKhB,YAAce,GADNA,YAY5CrD,EAAoBuD,UAAY,CAC5BC,aAAcC,IAAUC,KAAKC,Y,MChCjCC,IAASC,OACL,cAAC,EAAD,IACFC,SAASC,eAAe,W","file":"static/js/main.9b0775ca.chunk.js","sourcesContent":["import React, {useState} from 'react'\r\n// Este componente es un cuadro de texto, tiene dos manejadores\r\n// cuando algo cambia, se actualiza el estado\r\n// cuando se le da a enviar...\r\nexport const AddCategoryFromText = ({ ponCategoriaEnPadre }) => {\r\n    \r\n    //La caja de texto tendrá algún tipo de estado para poder saber lo que el usuario\r\n    //está escribiendo\r\n    const [textoParaCaja, settextoParaCaja] = useState('Introduzca búsqueda');\r\n    \r\n    const handleInputChange = (e) => {\r\n        settextoParaCaja (e.target.value);\r\n    }\r\n\r\n    // Con preventDefault() impedimos que el formulario se comporte por defecto\r\n    // como lo hacían los antiguos, en este caso refrescando la página aunque no se envíe nada\r\n    const handleSubmit = (e) => {\r\n        e.preventDefault();\r\n        \r\n        // Cuando de a submit quiero ejecutar la función setCategory que este componente\r\n        // recibe como parámetro para actualizar allí la lista\r\n        // como no he pasado el array de categorías como parámetro uso la función\r\n        // callback que puede ser llamada con el estado anterior\r\n        //\r\n        if (textoParaCaja.trim().length > 2) {\r\n        ponCategoriaEnPadre(categs => [textoParaCaja, ...categs]);\r\n        // si pongo e.textoParaCaja sale vacío, no se por qué\r\n        // Una vez insertado borro el valor de textoParaCaja\r\n        settextoParaCaja('');\r\n        //console.log('Formulario enviado');\r\n        }\r\n    }\r\n\r\n    // Con el return yo envío en lo que consiste el componente\r\n    //Como el form agrupa a todo lo que yo quiero enviar no me hace falta el fragment\r\n    return (\r\n        <form onSubmit={ handleSubmit}>\r\n            <input \r\n                type=\"text\"\r\n                value={textoParaCaja}\r\n                onChange={ handleInputChange }\r\n\r\n            />\r\n        </form>\r\n    )\r\n}\r\n","\r\n\r\n\r\nexport   const getGifs = async( categoria ) => {\r\n\r\n    const url = `https://api.giphy.com/v1/gifs/search?api_key=0QLXsShpMVIgEqUf2rwNrQGMMKzieiW5&q=${encodeURI(categoria)}&limit=10`;\r\n        const resp = await fetch( url );\r\n        \r\n        //Solamente me interesa el campo data del json que obtengo como respuesta\r\n        const { data } = await resp.json();\r\n\r\n        // De todo el data solo me interesan los campos id, title y downsized_medium.url\r\n        // con data.map voy recorriendo el arreglo data y cada elemento se va asociando\r\n        // a la variable img de la que luego saco lo que me interesa\r\n        const gifs = data.map( img => {\r\n            return {\r\n                id: img.id,\r\n                title: img.title,\r\n                url: img.images?.downsized_medium.url\r\n            }\r\n        })\r\n         return gifs;\r\n        //La constante gifs no la puedo usar fuera de esta función porque no existirá\r\n    }\r\n","import React from 'react'\r\n\r\n//En el componente recibimos las propiedades deconstruidas en vez de todo el elemento imagen\r\nexport const GridItem = ( {id,title, url}) => {\r\n    \r\n    console.log({id,title,url});\r\n\r\n    return (\r\n        <div className=\"card animate__animated animate__fadeIn\">\r\n            <h3>{title}</h3>\r\n            <img src={url} alt={title}/>\r\n        </div>\r\n    )\r\n}\r\n","import React, {useState, useEffect} from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\nimport { GridItem } from './GridItem';\r\nexport const GifGrid = ({ categorGrid }) => {\r\n\r\n    // Al deconstruir puedo asignar valres nuevos a los campos\r\n   const {data:imagenesEncontradas, loading} = useFetchGifs(categorGrid);\r\n\r\n   // Este efecto me lo llevo al custom hook\r\n//    useEffect( () => {\r\n//        getGifs(categorGrid) //nos devuelve una promesa\r\n//        .then( ponerImagenes );//esto es una abreviatura de lo siguiente comentado:\r\n//        // .then( gifsEncontrados => ponerImagenes(gifsEncontrados));\r\n//    }, [categorGrid])\r\n\r\n\r\n    //Según está esta función React volverá a lanzar la petición API cuando pulse el botón\r\n    // que incrementa el número count en 1, esto lo hace porque detecta un cambio\r\n    // en el componente y debe actualizar las referencias.\r\n    // Si estoy almacenando las imágenes en un array, por ejemplo, me lo llenará\r\n    // de cosas repetidas\r\n    // PARA QUE ESTO NO OCURRA DEBE UTILIZARSE useEffect\r\n    return (\r\n        <>\r\n        <h3> { categorGrid } </h3>\r\n        { loading && 'Cargando...'}\r\n        <div className=\"card-grid\">\r\n            \r\n                {\r\n                imagenesEncontradas.map( currentImg => (\r\n                 <GridItem \r\n                    key = {currentImg.id}\r\n                    //Con esto le envío los datos de la imagen\r\n                    {...currentImg}\r\n                    />\r\n                ))\r\n                }\r\n            </div>\r\n        </>\r\n    )\r\n}\r\n","// Esto es un custom hook\r\nimport { useState, useEffect } from 'react'\r\nimport { getGifs } from '../helpers/getGifs';\r\n\r\nexport const useFetchGifs = (categorGridForHook) => {\r\n\r\n    const [state, setState] = useState  ({\r\n        data: [],\r\n        loading: true\r\n    });\r\n    console.log('Categoría '+categorGridForHook);\r\n    \r\n    // Utilizando useEffect consigo que solamente se ejecute una vez al cargar el componente\r\n    // al poner como segundo parámetro  [categorGridForHook] también le digo que se ejecute\r\n    // cuando cambie la categoría categorGridForHook, pero esto no va a ocurrir\r\n    useEffect( () => {\r\n        getGifs(categorGridForHook) //nos devuelve una promesa\r\n        .then( gifsEncontrados => {\r\n\r\n           \r\n            setTimeout( () => {\r\n                \r\n            console.log(gifsEncontrados);\r\n            setState({\r\n                data: gifsEncontrados,\r\n                loading: false\r\n            });\r\n\r\n        }, 3000);\r\n        })\r\n    }, [categorGridForHook])\r\n\r\n\r\n    //setTimeout es una función que recibe dos parámetros\r\n    // El primero es una función callback que se ejecutará cuando\r\n    // pase el tiempo en ms especificado en el segundo parámetro\r\n    // setTimeout( () => {\r\n    //     setState({\r\n    //         data: [1,2,3],\r\n    //         loading: false\r\n    //     })\r\n    // }, 3000)\r\n\r\n    //La primera vez que se entra en esta función hook\r\n    // se devuelve es estado inicial, al pasar\r\n    // 3 segundos se vovlerá a devolver el nuevo estado\r\n    // y OJO, cada tres segundos se seguirá devolviendo eso, NO SE POR QUÉ\r\n    console.log('ENVIO COSAS!!!');\r\n    return state;\r\n}\r\n","import React, {useState} from 'react'\r\nimport {AddCategoryFromText} from './components/AddCategoryFromText';\r\n//Para hacer el parámetro ponCategoria obligaotorio\r\nimport PropTypes from 'prop-types';\r\nimport {GifGrid}  from './components/GifGrid';\r\n\r\n\r\nexport const GifExpertApp = () => {\r\n    \r\n    const [categories, setCatergory] = useState (['Chihiro']);\r\n\r\n    return (\r\n        <>\r\n            <h2>GifExpertApp</h2>\r\n            {/*En ponCategoria irá una referencia a la función setCategory\r\n                por lo que podré cambiar las categorías desde allí donde se\r\n                reciba ese parámetro */}\r\n            <AddCategoryFromText ponCategoriaEnPadre={ (setCatergory) } />\r\n            {/*Le paso al componente una función que sirve para manipular las categorías\r\n            en su padre, que soy yo. AddCategoryFromText podrá hacerme cosas por tanto */}\r\n            <hr />\r\n            <ol>\r\n                {\r\n                    //Aquí hay que usar una expresión que devuelva algo\r\n                    categories.map( (category, ind) => {\r\n                        return <GifGrid \r\n                                    key = { category }\r\n                                    categorGrid={ category } />\r\n                    })\r\n                }\r\n\r\n            </ol>\r\n        </>\r\n    )\r\n}\r\n\r\n//Con esto hacemos el parámetro ponCategoría requerido, para que el que use\r\n// mi componente tenga que enviar siempre el parámetro\r\nAddCategoryFromText.propTypes = {\r\n    ponCategoria: PropTypes.func.isRequired\r\n};","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport {GifExpertApp} from './GifExpertApp';\n\nimport './index.css';\n\nReactDOM.render(\n    <GifExpertApp />,\n  document.getElementById('root')\n);\n\n\n// Crear un componente GiftEXpertApp\n\n"],"sourceRoot":""}